doWhat query_Processing(string &s)
{
	struct doWhat
	{
		string filetype = "\0";
		string intitle = "\0";
		vector<string> task;
	} result;
	if (s == "\0") return;
	string tmp;
	vector<string> queue;
	for (string::iterator i = s.begin();i < s.end();i++)
	{
		if (*i == ' ') continue;
		while (*i != ' ' && *i != ',' && *i != '.' && *i != ';')
		{
			if (*i == '"')
			{
				tmp.push_back(*i);
				i++;
				for (;i < s.end() && *i != '"';i++)
					tmp.push_back(*i);
				if (*i == '"') tmp.push_back(*i);
				break;
			}
			else {
				tmp.push_back(*i);
				i++;
				if (i < s.end()) continue;
				else break;
			}
		}
		queue.push_back(tmp);
		if (i == s.end()) break;
		tmp = "\0";
	}
	doWhat result;
	for (vector<string>::iterator i = queue.begin();i<queue.end();i++)
		if (i->substr(0, 8) == "intitle:")// intitle:
		{
			result.intitle = i->substr(8);
		}
		else if (i->substr(0, 9) == "filetype:") // filetype:
		{
			result.filetype = i->substr(9);
		}
		else
		{
			result.task.push_back(*i);
		}
	return result;


}
void search(doWhat result)// here just the idea, syntax and some variables is not right
{
	vector<string>::iterator i = result.task.begin();
	int *point = new int[]; // number of trie
	int type = 0;
	while (i < result.task.end())
	{
		 if (*i == "AND")
		{
			int *tmp = new int[]; // number of trie
			type = 1;
			while (i < result.task.end())
			{
				if (i->find("\"") search_exact(*i); // phai dua point vao array tmp
				else search_nomal(i*);
			}
			break;
		}
		else if (*i == "OR")
		{
			int *tmp = new int[]; // number of trie
			type = 2;
			while (i < result.task.end())
			{
				if (i->find("\"") search_exact(*i); // phai dua point vao array tmp
				else search_nomal(i*);
			}
			break;
		}
		else 
		{
			if (i->find("\"") search_exact(*i);
			else search_nomal(i*);
		}
	}

	if (type == 0) trie_point[i] = point[i];
		if (type == 1)
		{
			for (int i = 0;i < /* number of trie ;*/;i++)
				if (point[i] > 0 && tmp[i] > 0)
					trie_point = point[i] + tmp[i];
				else trie_point = 0;
		}

		if (type == 2)
		{
			// mearge them together 
		}
		// ranking processs
}
